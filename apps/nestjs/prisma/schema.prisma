generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     Int              @id @default(autoincrement())
  username               String           @unique
  login42                String           @unique
  avatar                 String?
  twoFactorEnabled       Boolean          @default(false)
  twoFactorSecret        String?
  status                 e_user_status    @default(dbgenerated("'ONLINE'::e_user_status"))
  wins                   Int              @default(0)
  losses                 Int              @default(0)
  createdAt              DateTime         @default(now())
  updatedAt              DateTime         @updatedAt
  blocked                Blocked[]        @relation("BlockedA")
  blockedBy              Blocked[]        @relation("BlockedB")
  friendRequestsSent     FriendRequests[] @relation("FriendRequestsA")
  friendRequestsReceived FriendRequests[] @relation("FriendRequestsB")
  friends                Friends[]        @relation("FriendsA")
  friendOf               Friends[]        @relation("FriendsB")
  memberOf               Member[]
  history                Match[]          @relation("MatchToUser")

  @@map("users")
}

model Friends {
  userA_id Int
  userB_id Int
  userA    User @relation("FriendsA", fields: [userA_id], references: [id], onDelete: Cascade)
  userB    User @relation("FriendsB", fields: [userB_id], references: [id], onDelete: Cascade)

  @@id([userA_id, userB_id])
  @@map("_Friends")
}

model Blocked {
  userA_id Int
  userB_id Int
  userA    User @relation("BlockedA", fields: [userA_id], references: [id], onDelete: Cascade)
  userB    User @relation("BlockedB", fields: [userB_id], references: [id], onDelete: Cascade)

  @@id([userA_id, userB_id])
  @@map("_Blocked")
}

model FriendRequests {
  userA_id Int
  userB_id Int
  userA    User @relation("FriendRequestsA", fields: [userA_id], references: [id], onDelete: Cascade)
  userB    User @relation("FriendRequestsB", fields: [userB_id], references: [id], onDelete: Cascade)

  @@id([userA_id, userB_id])
  @@map("_FriendRequests")
}

model Match {
  id        Int           @id @default(autoincrement())
  score1    Int           @default(0)
  score2    Int           @default(0)
  map       e_match_map   @default(dbgenerated("'CLASSIC'::e_match_map"))
  powerUp   Boolean       @default(false)
  state     e_match_state @default(dbgenerated("'PREPARATION'::e_match_state"))
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  playedBy  User[]        @relation("MatchToUser")

  @@map("matches")
}

model Room {
  id      Int           @id @default(autoincrement())
  name    String?
  access  e_room_access @default(dbgenerated("'PUBLIC'::e_room_access"))
  hash    String?
  members Member[]

  @@map("rooms")
}

model Member {
  room_id     Int
  user_id     Int
  role        e_member_role @default(dbgenerated("'MEMBER'::e_member_role"))
  muted       Boolean       @default(false)
  muted_until DateTime      @default(now())
  banned      Boolean       @default(false)
  room        Room          @relation(fields: [room_id], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [user_id], references: [id], onDelete: Cascade)
  messages    Message[]

  @@id([room_id, user_id])
  @@map("members")
}

model Message {
  id        Int      @id @default(autoincrement())
  room_id   Int
  user_id   Int
  content   String
  createdAt DateTime @default(now())
  room      Member   @relation(fields: [room_id, user_id], references: [room_id, user_id])

  @@map("messages")
}

enum e_user_status {
  ONLINE
  INQUEUE
  INGAME
  OFFLINE
}

enum e_match_map {
  CLASSIC
}

enum e_match_state {
  PREPARATION
  INPROGRESS
  FINISHED
}

enum e_room_access {
  PUBLIC
  PROTECTED
  PRIVATE
  DIRECT_MESSAGE
}

enum e_member_role {
  OWNER
  ADMIN
  MEMBER
}
